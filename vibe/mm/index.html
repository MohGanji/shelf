<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keyboard First Mindmap</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Shantell+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #f8f9fa;
            --grid-color: #e9ecef;
            --node-bg: #ffffff;
            --node-bg-hover: #ffffff;
            --node-bg-edit: #ffffff;
            --node-border: #000000;
            --node-border-active: #000000;
            --text-color: #212529;
            --text-muted: #6c757d;
            --accent: #2f80ed;
            --accent-hover: #2d70d1;
            --accent-glow: rgba(47, 128, 237, 0.3);
            --selection-glow: 0 0 0 2px var(--accent);
            --edit-glow: 0 0 0 3px var(--accent-glow);
            --line-color: #000000;
            --font-family: 'Shantell Sans', sans-serif;
            --shadow-md: 4px 4px 0px 0px rgba(0, 0, 0, 0.1);
            --shadow-lg: 8px 8px 0px 0px rgba(0, 0, 0, 0.1);
            --backdrop: #ffffff;
            --radius-md: 8px;
            --radius-lg: 12px;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            background-image: radial-gradient(var(--text-muted) 1px, transparent 1px);
            background-size: 20px 20px;
            font-family: var(--font-family);
            color: var(--text-color);
            user-select: none;
            -webkit-font-smoothing: antialiased;
        }

        #app {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform-origin: 0 0;
            transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
            z-index: 1;
        }

        #connections {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            overflow: visible;
        }
        
        #nodes-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: visible;
        }

        path {
            fill: none;
            stroke: var(--line-color);
            stroke-width: 2px;
            transition: d 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .node {
            position: absolute;
            background: var(--node-bg);
            border: 2px solid var(--node-border);
            padding: 12px 18px;
            border-radius: var(--radius-lg);
            min-width: 100px;
            max-width: 280px; 
            font-size: 16px;
            font-weight: 500;
            line-height: 1.5;
            cursor: pointer;
            z-index: 1;
            transition: 
                transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1), 
                opacity 0.3s ease,
                background-color 0.2s ease,
                box-shadow 0.2s ease,
                border-color 0.2s ease;
            box-shadow: var(--shadow-md);
            white-space: pre-wrap;
            word-wrap: break-word;
            outline: none;
            color: var(--text-color);
        }
        
        .node:hover {
            background: var(--node-bg-hover);
            border-color: var(--node-border-active);
            transform: translateY(-2px);
            box-shadow: 6px 6px 0px 0px rgba(0, 0, 0, 0.1);
        }

        body.edit-mode .node:not(.editing) {
            opacity: 0.5;
            filter: grayscale(0.5);
        }

        .node.selected {
            border-color: var(--accent);
            box-shadow: var(--shadow-md);
            z-index: 10;
        }

        .node.editing {
            background-color: var(--node-bg-edit);
            box-shadow: var(--edit-glow), var(--shadow-lg);
            z-index: 100;
            border-color: var(--accent);
            border-width: 2px;
            cursor: text;
            opacity: 1 !important;
            filter: none;
        }

        .node.read {
            background-color: #d4edda;
            border-color: #28a745;
        }

        .node.selected.read {
            border-color: var(--accent);
        }

        .node:empty:before {
            content: "Node";
            color: var(--text-muted);
            font-style: normal;
            font-weight: 400;
        }

        #ui-layer {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--backdrop);
            padding: 8px 16px;
            border-radius: var(--radius-md);
            font-size: 14px;
            color: var(--text-color);
            pointer-events: none;
            z-index: 100;
            border: 2px solid var(--node-border);
            box-shadow: var(--shadow-md);
        }
        
        .mode-indicator {
            font-weight: 700;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-right: 8px;
        }

        #help-btn {
            position: fixed;
            bottom: 24px;
            right: 24px;
            width: 40px;
            height: 40px;
            border-radius: var(--radius-md);
            background: var(--backdrop);
            border: 2px solid var(--node-border);
            color: var(--text-color);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            font-weight: 700;
            z-index: 100;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-md);
        }

        #help-btn:hover {
            transform: translate(-2px, -2px);
            box-shadow: 6px 6px 0px 0px rgba(0, 0, 0, 0.1);
        }

        #help-modal, #message-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--backdrop);
            border: 2px solid var(--node-border);
            border-radius: var(--radius-lg);
            padding: 24px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 12px 12px 0px 0px rgba(0, 0, 0, 0.1);
            display: none;
        }

        #help-modal.active, #message-modal.active {
            display: block;
            animation: modalFadeIn 0.2s ease-out;
        }

        @keyframes modalFadeIn {
            from { opacity: 0; transform: translate(-50%, -48%); }
            to { opacity: 1; transform: translate(-50%, -50%); }
        }

        #help-modal-overlay, #message-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(2px);
            z-index: 999;
            display: none;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        #help-modal-overlay.active, #message-modal-overlay.active {
            display: block;
            opacity: 1;
        }

        .help-header, .message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 2px solid var(--grid-color);
        }

        .help-title, .message-title {
            font-size: 20px;
            font-weight: 700;
            color: var(--text-color);
        }

        .help-close, .message-close {
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 24px;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .help-close:hover, .message-close:hover {
            background: var(--grid-color);
        }

        .message-content {
            color: var(--text-color);
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 24px;
        }

        .message-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .message-btn {
            background: transparent;
            border: 2px solid var(--node-border);
            color: var(--text-color);
            padding: 8px 16px;
            border-radius: var(--radius-md);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            font-family: var(--font-family);
            transition: all 0.2s ease;
            box-shadow: 2px 2px 0px 0px rgba(0, 0, 0, 0.1);
        }

        .message-btn:hover {
            transform: translate(-1px, -1px);
            box-shadow: 4px 4px 0px 0px rgba(0, 0, 0, 0.1);
        }

        .message-btn.primary {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .message-btn.primary:hover {
            background: var(--accent-hover);
            border-color: var(--accent-hover);
        }

        .help-section {
            margin-bottom: 28px;
        }

        .help-section:last-child {
            margin-bottom: 0;
        }

        .help-section-title {
            font-size: 14px;
            font-weight: 700;
            color: var(--text-muted);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .help-shortcut {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid var(--grid-color);
        }

        .help-shortcut:last-child {
            border-bottom: none;
        }

        .help-action {
            color: var(--text-color);
            font-size: 15px;
            font-weight: 500;
        }

        .help-keys {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .help-key {
            background: #ffffff;
            border: 2px solid var(--grid-color);
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-color);
            font-family: inherit;
            min-width: 20px;
            text-align: center;
            box-shadow: 0 2px 0 var(--grid-color);
        }

        #controls-layer {
            position: fixed;
            top: 24px;
            left: 24px;
            display: flex;
            gap: 12px;
            z-index: 100;
        }

        .control-btn {
            background: var(--backdrop);
            border: 2px solid var(--node-border);
            color: var(--text-color);
            padding: 8px 16px;
            border-radius: var(--radius-md);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            font-family: var(--font-family);
            transition: all 0.2s ease;
            box-shadow: var(--shadow-md);
        }

        .control-btn:hover {
            transform: translate(-2px, -2px);
            box-shadow: 6px 6px 0px 0px rgba(0, 0, 0, 0.1);
        }

        #file-input {
            display: none;
        }
    </style>
</head>
<body>

    <div id="app">
        <svg id="connections" width="100%" height="100%" style="overflow: visible;">
            <defs>
                <style>
                    path { vector-effect: non-scaling-stroke; }
                </style>
            </defs>
        </svg>
        <div id="nodes-container"></div>
    </div>

    <div id="ui-layer">
        <span id="mode-display" class="mode-indicator">VIEW</span>
    </div>

    <button id="help-btn" title="Help">?</button>

    <div id="help-modal-overlay"></div>
    <div id="help-modal">
        <div class="help-header">
            <div class="help-title">Keyboard Shortcuts</div>
            <button class="help-close" id="help-close">&times;</button>
        </div>
        
        <div class="help-section">
            <div class="help-section-title">Navigation</div>
            <div class="help-shortcut">
                <span class="help-action">Navigate to parent</span>
                <div class="help-keys">
                    <span class="help-key">←</span>
                </div>
            </div>
            <div class="help-shortcut">
                <span class="help-action">Navigate to child</span>
                <div class="help-keys">
                    <span class="help-key">→</span>
                </div>
            </div>
            <div class="help-shortcut">
                <span class="help-action">Navigate to sibling above</span>
                <div class="help-keys">
                    <span class="help-key">↑</span>
                </div>
            </div>
            <div class="help-shortcut">
                <span class="help-action">Navigate to sibling below</span>
                <div class="help-keys">
                    <span class="help-key">↓</span>
                </div>
            </div>
        </div>

        <div class="help-section">
            <div class="help-section-title">Editing</div>
            <div class="help-shortcut">
                <span class="help-action">Enter edit mode</span>
                <div class="help-keys">
                    <span class="help-key">Enter</span>
                </div>
            </div>
            <div class="help-shortcut">
                <span class="help-action">Exit edit mode</span>
                <div class="help-keys">
                    <span class="help-key">Enter</span>
                    <span class="help-key">Esc</span>
                </div>
            </div>
        </div>

        <div class="help-section">
            <div class="help-section-title">Node Operations</div>
            <div class="help-shortcut">
                <span class="help-action">Add child node</span>
                <div class="help-keys">
                    <span class="help-key">Cmd</span>
                    <span class="help-key">→</span>
                </div>
            </div>
            <div class="help-shortcut">
                <span class="help-action">Add sibling above</span>
                <div class="help-keys">
                    <span class="help-key">Cmd</span>
                    <span class="help-key">↑</span>
                </div>
            </div>
            <div class="help-shortcut">
                <span class="help-action">Add sibling below</span>
                <div class="help-keys">
                    <span class="help-key">Cmd</span>
                    <span class="help-key">↓</span>
                </div>
            </div>
            <div class="help-shortcut">
                <span class="help-action">Delete node</span>
                <div class="help-keys">
                    <span class="help-key">Cmd</span>
                    <span class="help-key">Delete</span>
                </div>
            </div>
            <div class="help-shortcut">
                <span class="help-action">Mark as done</span>
                <div class="help-keys">
                    <span class="help-key">Space</span>
                </div>
            </div>
        </div>

        <div class="help-section">
            <div class="help-section-title">History</div>
            <div class="help-shortcut">
                <span class="help-action">Undo</span>
                <div class="help-keys">
                    <span class="help-key">Cmd</span>
                    <span class="help-key">Z</span>
                </div>
            </div>
            <div class="help-shortcut">
                <span class="help-action">Redo</span>
                <div class="help-keys">
                    <span class="help-key">Cmd</span>
                    <span class="help-key">Shift</span>
                    <span class="help-key">Z</span>
                </div>
            </div>
        </div>

        <div class="help-section">
            <div class="help-section-title">Zoom</div>
            <div class="help-shortcut">
                <span class="help-action">Zoom in</span>
                <div class="help-keys">
                    <span class="help-key">Cmd</span>
                    <span class="help-key">Shift</span>
                    <span class="help-key">+</span>
                </div>
            </div>
            <div class="help-shortcut">
                <span class="help-action">Zoom out</span>
                <div class="help-keys">
                    <span class="help-key">Cmd</span>
                    <span class="help-key">Shift</span>
                    <span class="help-key">-</span>
                </div>
            </div>
        </div>
    </div>

    <div id="controls-layer">
        <button class="control-btn" id="download-btn">Download</button>
        <button class="control-btn" id="upload-btn">Upload</button>
        <button class="control-btn" id="reset-btn">Reset</button>
    </div>

    <input type="file" id="file-input" accept=".json" />

    <div id="message-modal-overlay"></div>
    <div id="message-modal">
        <div class="message-header">
            <div class="message-title" id="message-title">Message</div>
            <button class="message-close" id="message-close">&times;</button>
        </div>
        <div class="message-content" id="message-content"></div>
        <div class="message-actions" id="message-actions">
            <button class="message-btn primary" id="message-ok">OK</button>
        </div>
    </div>

    <script>
        const defaultState = {
            nodes: {
                'root': { id: 'root', text: 'Root Node', parentId: null, children: [] }
            },
            rootId: 'root',
            selectedId: 'root',
            zoom: 1,
            pan: { x: 50, y: window.innerHeight / 2 - 20 },
            readNodes: {}
        };

        let state = JSON.parse(JSON.stringify(defaultState));
        if (!state.readNodes) state.readNodes = {};
        let mode = 'VIEW';
        let historyStack = [];
        let redoStack = [];
        const NODE_WIDTH = 220;

        const appEl = document.getElementById('app');
        const nodesContainer = document.getElementById('nodes-container');
        const svgEl = document.getElementById('connections');
        const modeDisplay = document.getElementById('mode-display');

        function loadState() {
            const saved = localStorage.getItem('mindmap_state');
            if (saved) {
                try {
                    state = JSON.parse(saved);
                    if(!state.nodes['root']) state = JSON.parse(JSON.stringify(defaultState));
                    if (!state.readNodes) state.readNodes = {};
                } catch(e) { console.error("Save load failed", e); }
            }
            render();
        }

        function saveState() {
            localStorage.setItem('mindmap_state', JSON.stringify(state));
        }

        function pushHistory() {
            historyStack.push(JSON.stringify(state));
            if (historyStack.length > 50) historyStack.shift();
            redoStack = [];
        }

        function createId() {
            return 'node_' + Math.random().toString(36).substr(2, 9);
        }

        function addChild(parentId) {
            pushHistory();
            const newId = createId();
            const newNode = { id: newId, text: 'new node', parentId: parentId, children: [] };
            
            state.nodes[newId] = newNode;
            state.nodes[parentId].children.push(newId);
            
            state.selectedId = newId;
            saveState();
            render();
            enterEditMode();
        }

        function addSibling(referenceId, direction) {
            if (referenceId === state.rootId) return; 
            
            pushHistory();
            const parentId = state.nodes[referenceId].parentId;
            const parent = state.nodes[parentId];
            const newId = createId();
            const newNode = { id: newId, text: 'new node', parentId: parentId, children: [] };
            
            state.nodes[newId] = newNode;
            
            const index = parent.children.indexOf(referenceId);
            if (direction === 'up') {
                parent.children.splice(index, 0, newId);
            } else {
                parent.children.splice(index + 1, 0, newId);
            }

            state.selectedId = newId;
            saveState();
            render();
            enterEditMode();
        }

        function deleteNode(id) {
            if (id === state.rootId) return;
            pushHistory();
            
            const node = state.nodes[id];
            const parent = state.nodes[node.parentId];
            
            const idx = parent.children.indexOf(id);
            if (idx > 0) state.selectedId = parent.children[idx - 1];
            else if (parent.children.length > 1) state.selectedId = parent.children[idx + 1];
            else state.selectedId = node.parentId;

            function deleteRecursive(nodeId) {
                state.nodes[nodeId].children.forEach(deleteRecursive);
                delete state.nodes[nodeId];
            }
            
            parent.children.splice(idx, 1);
            deleteRecursive(id);

            saveState();
            render();
        }

        function undo() {
            if (historyStack.length === 0) return;
            redoStack.push(JSON.stringify(state));
            state = JSON.parse(historyStack.pop());
            saveState();
            render();
        }

        function redo() {
            if (redoStack.length === 0) return;
            historyStack.push(JSON.stringify(state));
            state = JSON.parse(redoStack.pop());
            saveState();
            render();
        }

        function measureNodeWidth(nodeId) {
            const node = state.nodes[nodeId];
            const tempEl = document.createElement('div');
            tempEl.className = 'node';
            tempEl.style.position = 'absolute';
            tempEl.style.visibility = 'hidden';
            tempEl.style.whiteSpace = 'pre-wrap';
            tempEl.innerText = node.text;
            document.body.appendChild(tempEl);
            const width = Math.max(tempEl.offsetWidth, 100);
            document.body.removeChild(tempEl);
            return Math.min(width, 280);
        }

        function calculateLayout() {
            const layoutData = {};
            const nodeWidths = {};
            const HORIZONTAL_PADDING = 80;
            const BORDER_WIDTH = 2;
            const SHADOW_OFFSET = 4;
            
            Object.keys(state.nodes).forEach(id => {
                const el = document.getElementById(id);
                if (el && el.offsetWidth > 0) {
                    nodeWidths[id] = Math.min(Math.max(el.offsetWidth, 100), 280);
                } else {
                    nodeWidths[id] = measureNodeWidth(id);
                }
            });
            
            function measure(nodeId, depth) {
                const node = state.nodes[nodeId];
                let height = 0;
                
                if (node.children.length === 0) {
                    height = 80; 
                } else {
                    node.children.forEach(childId => {
                        height += measure(childId, depth + 1);
                    });
                }
                
                layoutData[nodeId] = { 
                    width: nodeWidths[nodeId] || NODE_WIDTH, 
                    height: height, 
                    x: 0,
                    y: 0,
                    depth: depth 
                };
                return height;
            }
            
            measure(state.rootId, 0);

            function assignX(nodeId, xOffset) {
                const node = state.nodes[nodeId];
                const data = layoutData[nodeId];
                const nodeWidth = nodeWidths[nodeId] || NODE_WIDTH;
                const totalNodeWidth = nodeWidth + (BORDER_WIDTH * 2) + SHADOW_OFFSET;
                
                data.x = xOffset;
                
                if (node.children.length > 0) {
                    const childXOffset = xOffset + totalNodeWidth + HORIZONTAL_PADDING;
                    node.children.forEach(childId => {
                        assignX(childId, childXOffset);
                    });
                }
            }

            function assignY(nodeId, yOffset) {
                const node = state.nodes[nodeId];
                const data = layoutData[nodeId];
                const childrenHeight = data.height;
                
                data.y = yOffset + (childrenHeight / 2);

                let currentY = yOffset;
                node.children.forEach(childId => {
                    assignY(childId, currentY);
                    currentY += layoutData[childId].height;
                });
            }

            assignX(state.rootId, 50);
            assignY(state.rootId, -layoutData[state.rootId].height/2);
            return layoutData;
        }

        function render() {
            const layout = calculateLayout();
            
            const existingEls = Array.from(nodesContainer.children);
            const activeIds = new Set(Object.keys(state.nodes));
            
            existingEls.forEach(el => {
                if (!activeIds.has(el.id)) el.remove();
            });

            Object.keys(state.nodes).forEach(id => {
                let el = document.getElementById(id);
                const node = state.nodes[id];
                const pos = layout[id];

                if (!el) {
                    el = document.createElement('div');
                    el.id = id;
                    el.className = 'node';
                    el.contentEditable = false;
                    el.innerText = node.text;

                    el.style.transition = 'none';
                    el.style.opacity = '0';
                    const initialTransform = `translate(${pos.x}px, ${pos.y - el.offsetHeight/2}px) scale(0.5)`;
                    el.style.transform = initialTransform;

                    el.addEventListener('click', (e) => {
                        e.stopPropagation();
                        state.selectedId = id;
                        render();
                    });
                    nodesContainer.appendChild(el);

                    if (state.readNodes && state.readNodes[id]) {
                        el.classList.add('read');
                    }

                    el.offsetHeight;
                    el.style.transition = '';

                    requestAnimationFrame(() => {
                        el.style.opacity = '1';
                        const finalTransform = `translate(${pos.x}px, ${pos.y - el.offsetHeight/2}px) scale(1)`;
                        el.style.transform = finalTransform;
                    });
                } else {
                    if (document.activeElement !== el) {
                        el.innerText = node.text;
                    }

                    let transform = `translate(${pos.x}px, ${pos.y - el.offsetHeight/2}px)`;

                    if (id === state.selectedId) {
                        el.classList.add('selected');
                        if (mode === 'EDIT') {
                            transform += ' scale(1.08)';
                            el.classList.add('editing');
                        } else {
                            el.classList.remove('editing');
                        }
                    } else {
                        el.classList.remove('selected');
                        el.classList.remove('editing');
                    }

                    if (state.readNodes && state.readNodes[id]) {
                        el.classList.add('read');
                    } else {
                        el.classList.remove('read');
                    }

                    el.style.transform = transform;
                    el.style.opacity = '1';
                }
            });

            while (svgEl.firstChild) svgEl.removeChild(svgEl.firstChild);
            
            Object.keys(state.nodes).forEach(id => {
                const node = state.nodes[id];
                const startPos = layout[id];
                const startNodeEl = document.getElementById(id);
                if (!startNodeEl) return;

                node.children.forEach(childId => {
                    const endPos = layout[childId];
                    const endNodeEl = document.getElementById(childId);
                    if (!endNodeEl) return;

                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    const nodeWidth = startNodeEl.offsetWidth || NODE_WIDTH;
                    const sx = startPos.x + nodeWidth;
                    const sy = startPos.y;
                    const ex = endPos.x;
                    const ey = endPos.y;

                    const cx1 = sx + (ex - sx) / 2;
                    const cy1 = sy;
                    const cx2 = ex - (ex - sx) / 2;
                    const cy2 = ey;

                    const d = `M ${sx} ${sy} C ${cx1} ${cy1} ${cx2} ${cy2} ${ex} ${ey}`;
                    path.setAttribute('d', d);
                    svgEl.appendChild(path);
                });
            });

            appEl.style.transform = `translate(${state.pan.x}px, ${state.pan.y}px) scale(${state.zoom})`;

            const panBefore = { x: state.pan.x, y: state.pan.y };
            ensureNodeVisible(state.selectedId, layout);

            if (panBefore.x !== state.pan.x || panBefore.y !== state.pan.y) {
                appEl.style.transform = `translate(${state.pan.x}px, ${state.pan.y}px) scale(${state.zoom})`;
                requestAnimationFrame(() => {
                    render();
                });
            }
        }

        function ensureNodeVisible(nodeId, layout) {
            if (!layout[nodeId]) return;

            const nodePos = layout[nodeId];
            const nodeEl = document.getElementById(nodeId);
            if (!nodeEl) return;

            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const paddingX = viewportWidth * 0.2;
            const paddingY = viewportHeight * 0.2;

            const nodeWorldX = nodePos.x;
            const nodeWorldY = nodePos.y;
            const nodeScreenX = (nodeWorldX + state.pan.x) * state.zoom;
            const nodeScreenY = (nodeWorldY + state.pan.y) * state.zoom;

            const nodeHeight = nodeEl.offsetHeight * state.zoom;
            const nodeTop = nodeScreenY - nodeHeight / 2;
            const nodeBottom = nodeScreenY + nodeHeight / 2;

            const visibleLeft = paddingX;
            const visibleRight = viewportWidth - paddingX;
            const visibleTop = paddingY;
            const visibleBottom = viewportHeight - paddingY;

            let needsAdjustment = false;
            let newPanX = state.pan.x;
            let newPanY = state.pan.y;

            if (nodeScreenX < visibleLeft) {
                newPanX = (visibleLeft / state.zoom) - nodeWorldX;
                needsAdjustment = true;
            } else if (nodeScreenX > visibleRight) {
                newPanX = (visibleRight / state.zoom) - nodeWorldX;
                needsAdjustment = true;
            }

            if (nodeTop < visibleTop) {
                const targetScreenY = visibleTop + nodeHeight / 2;
                newPanY = (targetScreenY / state.zoom) - nodeWorldY;
                needsAdjustment = true;
            } else if (nodeBottom > visibleBottom) {
                const targetScreenY = visibleBottom - nodeHeight / 2;
                newPanY = (targetScreenY / state.zoom) - nodeWorldY;
                needsAdjustment = true;
            }

            if (needsAdjustment) {
                state.pan.x = newPanX;
                state.pan.y = newPanY;
            }
        }

        function enterEditMode() {
            mode = 'EDIT';
            modeDisplay.innerText = 'EDIT';
            document.body.classList.add('edit-mode');
            render(); 
            
            const el = document.getElementById(state.selectedId);
            if (el) {
                el.contentEditable = true;
                el.focus();
                const range = document.createRange();
                range.selectNodeContents(el);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            }
        }

        function exitEditMode() {
            const el = document.getElementById(state.selectedId);
            if (el) {
                if (state.nodes[state.selectedId].text !== el.innerText) {
                     state.nodes[state.selectedId].text = el.innerText;
                     saveState();
                }
                el.contentEditable = false;
                el.blur();
            }
            mode = 'VIEW';
            modeDisplay.innerText = 'VIEW';
            document.body.classList.remove('edit-mode');
            render(); 
        }

        window.addEventListener('keydown', (e) => {
            const meta = e.metaKey || e.ctrlKey; 

            if (mode === 'EDIT') {
                if (e.key === 'Enter' || e.key === 'Escape') {
                    e.preventDefault();
                    exitEditMode();
                }
                return;
            }

            if (e.key === 'Enter' && !meta) {
                e.preventDefault();
                enterEditMode();
                return;
            }

            if (e.key === ' ' && !meta) {
                e.preventDefault();
                if (!state.readNodes) state.readNodes = {};
                if (state.readNodes[state.selectedId]) {
                    delete state.readNodes[state.selectedId];
                } else {
                    state.readNodes[state.selectedId] = true;
                }
                saveState();
                render();
                return;
            }

            if (!meta && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
                const current = state.nodes[state.selectedId];
                const parent = state.nodes[current.parentId];

                if (e.key === 'ArrowLeft') {
                    if (current.parentId) {
                        state.selectedId = current.parentId;
                    }
                } 
                else if (e.key === 'ArrowRight') {
                    if (current.children.length > 0) {
                        const mid = Math.floor(current.children.length / 2);
                        state.selectedId = current.children[mid];
                    }
                }
                else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                    if (parent) {
                        const idx = parent.children.indexOf(state.selectedId);
                        if (e.key === 'ArrowUp' && idx > 0) {
                            state.selectedId = parent.children[idx - 1];
                        } else if (e.key === 'ArrowDown' && idx < parent.children.length - 1) {
                            state.selectedId = parent.children[idx + 1];
                        }
                    }
                }
                render();
                return;
            }

            if (meta) {
                if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    addChild(state.selectedId);
                }
                else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    addSibling(state.selectedId, 'up');
                }
                else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    addSibling(state.selectedId, 'down');
                }
                else if (e.key === 'z') {
                    e.preventDefault();
                    if (e.shiftKey) redo();
                    else undo();
                }
                else if ((e.key === '=' || e.key === '+') && e.shiftKey) {
                    e.preventDefault();
                    state.zoom = Math.min(state.zoom + 0.1, 3);
                    render();
                }
                else if (e.key === '-' && e.shiftKey) {
                    e.preventDefault();
                    state.zoom = Math.max(state.zoom - 0.1, 0.2);
                    render();
                }
                else if (e.key === 'Backspace') {
                    e.preventDefault();
                    deleteNode(state.selectedId);
                }
            }
        });

        function showMessage(title, message, onConfirm = null) {
            document.getElementById('message-title').textContent = title;
            document.getElementById('message-content').textContent = message;
            const actionsDiv = document.getElementById('message-actions');
            actionsDiv.innerHTML = '';
            
            const okBtn = document.createElement('button');
            okBtn.className = 'message-btn primary';
            okBtn.textContent = 'OK';
            okBtn.onclick = () => {
                closeMessageModal();
                if (onConfirm) onConfirm();
            };
            actionsDiv.appendChild(okBtn);
            
            document.getElementById('message-modal').classList.add('active');
            document.getElementById('message-modal-overlay').classList.add('active');
        }

        function showConfirm(title, message, onConfirm, onCancel = null) {
            document.getElementById('message-title').textContent = title;
            document.getElementById('message-content').textContent = message;
            const actionsDiv = document.getElementById('message-actions');
            actionsDiv.innerHTML = '';
            
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'message-btn';
            cancelBtn.textContent = 'Cancel';
            cancelBtn.onclick = () => {
                closeMessageModal();
                if (onCancel) onCancel();
            };
            actionsDiv.appendChild(cancelBtn);
            
            const confirmBtn = document.createElement('button');
            confirmBtn.className = 'message-btn primary';
            confirmBtn.textContent = 'Confirm';
            confirmBtn.onclick = () => {
                closeMessageModal();
                if (onConfirm) onConfirm();
            };
            actionsDiv.appendChild(confirmBtn);
            
            document.getElementById('message-modal').classList.add('active');
            document.getElementById('message-modal-overlay').classList.add('active');
        }

        function closeMessageModal() {
            document.getElementById('message-modal').classList.remove('active');
            document.getElementById('message-modal-overlay').classList.remove('active');
        }

        function downloadState() {
            const dataStr = JSON.stringify(state, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'mindmap-data.json';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            showMessage('Download Complete', 'Mindmap data has been downloaded successfully.');
        }

        function validateStateFormat(data) {
            if (!data || typeof data !== 'object') return false;
            if (!data.nodes || typeof data.nodes !== 'object') return false;
            if (typeof data.rootId !== 'string') return false;
            if (typeof data.selectedId !== 'string') return false;
            if (typeof data.zoom !== 'number') return false;
            if (!data.pan || typeof data.pan.x !== 'number' || typeof data.pan.y !== 'number') return false;
            if (!data.nodes[data.rootId]) return false;
            if (data.readNodes && typeof data.readNodes !== 'object') return false;

            for (const nodeId in data.nodes) {
                const node = data.nodes[nodeId];
                if (!node.id || !node.text || typeof node.text !== 'string') return false;
                if (!Array.isArray(node.children)) return false;
                if (node.parentId !== null && typeof node.parentId !== 'string') return false;
            }

            return true;
        }

        function uploadState(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const uploadedData = JSON.parse(e.target.result);
                    
                    if (!validateStateFormat(uploadedData)) {
                        showMessage('Upload Failed', 'Invalid file format. The file does not match the expected mindmap structure.');
                        return;
                    }

                    state = uploadedData;
                    saveState();
                    render();
                    showMessage('Upload Complete', 'Mindmap data uploaded successfully!');
                } catch (error) {
                    showMessage('Upload Failed', 'Error reading file: ' + error.message);
                }
            };
            reader.onerror = function() {
                showMessage('Upload Failed', 'Error reading file.');
            };
            reader.readAsText(file);
        }

        function resetState() {
            showConfirm(
                'Reset Mindmap',
                'Are you sure you want to reset the mindmap? This will delete all your data and cannot be undone.',
                () => {
                    state = JSON.parse(JSON.stringify(defaultState));
                    saveState();
                    render();
                    showMessage('Reset Complete', 'Mindmap has been reset.');
                }
            );
        }

        document.getElementById('download-btn').addEventListener('click', downloadState);
        document.getElementById('upload-btn').addEventListener('click', () => {
            document.getElementById('file-input').click();
        });
        document.getElementById('reset-btn').addEventListener('click', resetState);
        document.getElementById('file-input').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                uploadState(e.target.files[0]);
                e.target.value = '';
            }
        });

        function toggleHelpModal() {
            const modal = document.getElementById('help-modal');
            const overlay = document.getElementById('help-modal-overlay');
            const isActive = modal.classList.contains('active');
            
            if (isActive) {
                modal.classList.remove('active');
                overlay.classList.remove('active');
            } else {
                modal.classList.add('active');
                overlay.classList.add('active');
            }
        }

        function closeHelpModal() {
            document.getElementById('help-modal').classList.remove('active');
            document.getElementById('help-modal-overlay').classList.remove('active');
        }

        document.getElementById('help-btn').addEventListener('click', toggleHelpModal);
        document.getElementById('help-close').addEventListener('click', closeHelpModal);
        document.getElementById('help-modal-overlay').addEventListener('click', closeHelpModal);

        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && mode !== 'EDIT') {
                const helpModal = document.getElementById('help-modal');
                const messageModal = document.getElementById('message-modal');
                if (helpModal.classList.contains('active')) {
                    closeHelpModal();
                } else if (messageModal.classList.contains('active')) {
                    closeMessageModal();
                }
            }
        });

        document.getElementById('message-close').addEventListener('click', closeMessageModal);
        document.getElementById('message-modal-overlay').addEventListener('click', closeMessageModal);

        loadState();
        
    </script>
</body>
</html>